## 🚀 Project Recap: Dm-Delay

You built a simple app where:

* User types a message
* Chooses a delay (in seconds)
* Clicks a button to **send the message after the delay**
* Can **cancel** it before time runs out

---

## 🔧 Technologies & Libraries Used

| Tool             | Purpose                                                      |
| ---------------- | ------------------------------------------------------------ |
| **React**        | Building UI using components                                 |
| **Vite**         | Fast dev server and bundler                                  |
| **TypeScript**   | Adds types to JS for safer code                              |
| **Tailwind CSS** | Utility-first styling                                        |
| **shadcn/ui**    | Prebuilt React components like `Textarea`, `Input`, `Button` |

---

## 🔑 Key React Concepts You Used

### 1. `useState` Hook

```tsx
const [message, setMessage] = useState<string>("");
```

* **What it does**: Creates a state variable (`message`) and a function (`setMessage`) to update it.
* **`useState<Type>()`**: In TypeScript, you define what type the state holds (here it's `string`).
* This state persists during re-renders.

#### Example from your code:

* `message`: Stores the user-typed text.
* `delay`: Stores how long (in seconds) before the message is sent.
* `isSending`: Boolean to check if a timer is running.
* `timer`: Holds the actual timer object (from `setTimeout`).
* `sentMessage`: Stores the final sent message to display it.

---

### 2. `setTimeout` and `clearTimeout`

```tsx
const id = setTimeout(() => {
    setSentMessage(message);
    setMessage(" ");
    setIsSending(false);
}, delay * 1000);
```

* `setTimeout(callback, timeInMs)` delays running the function.
* `clearTimeout(id)` cancels the timer using the ID from `setTimeout`.

This is the heart of the delayed message logic.

---

### 3. Event Handlers

#### `handleSend` Function:

Triggered when the **"Send with delay"** button is clicked.

```tsx
setIsSending(true); // UI changes to show cancel button
```

Starts a `setTimeout` and stores the ID in `timer`.

#### `handleCancel` Function:

Triggered when **"Cancel"** is clicked.

```tsx
if (timer) clearTimeout(timer); // stop the timer
```

Also resets the UI.

---

### 4. Conditional Rendering

```tsx
{!isSending ? (
    <Button onClick={handleSend}>Send with delay</Button>
) : (
    <Button variant="destructive" onClick={handleCancel}>Cancel Sending</Button>
)}
```

This part shows different buttons depending on whether a timer is active.

---

### 5. Input Components (`shadcn/ui`)

These are reusable components imported like this:

```tsx
import {Textarea} from './ui/textarea'
import {Input} from './ui/input'
import {Button} from './ui/button'
```

* Controlled components: The value of these inputs comes from `useState`, and updates on every keystroke.

Example:

```tsx
<Input
  type="number"
  value={delay}
  onChange={(e) => setDelay(Number(e.target.value))}
/>
```

---

### 6. JSX and Tailwind

```tsx
<div className='max-w-md mx-auto mt-20 p-6 border rounded-lg shadow-sm bg-white space-y-4'>
```

You’re using **Tailwind utility classes** directly in JSX for layout and design:

* `max-w-md`: max width
* `mx-auto`: center horizontally
* `mt-20`: margin top
* `space-y-4`: spacing between vertical children

---

## 🔁 Lifecycle (What happens step-by-step)

1. **User types a message** → `message` is updated
2. **User types delay** → `delay` is updated
3. **User clicks "Send"** → `setTimeout` starts
4. UI switches to **"Cancel"** button
5. After delay, `sentMessage` is shown and input is cleared
6. If **cancelled before timeout**, nothing is sent

---

